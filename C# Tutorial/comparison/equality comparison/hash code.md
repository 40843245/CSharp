# hash code in `C#`
## abstract
In [equality comparison in `C#` article](https://github.com/40843245/CSharp/blob/main/C%23%20Tutorial/comparison/equality%20comparison/equality%20comparison.md),

we have discussed that 

> In `C#`, compare two instance are considered to same with `IEqualityComparer<T>`,
>
> it will compare hash code first,
>
> then compare their value (if their hash code are considered to be same).

We will discussed why it does so.

Before diving it into the topic, we need to know hash code, hash function, its related terms.

## terms
### hash code

A hash code is a numerical value that is generated by hash function to identify a piece of data (as possible as it can).

A practically good hash function has these feature:

+ it has collision as less as possible

> [!NOTE]
> Ideally, we can design a perfect hash function so that there are no collison.
>
> However, in practically, it is hard to design a perfect hash function.

### hash collision
A hash collision refers given two different value, the hash code or something (generated by hash function) will be same. 

## Why less hash collison is better
1. sacrifice performance or data security

If a hash collision occurs, 

then it needs to identity two source datas are same using other approach.

And most of other approach are more (or even more) expensive than comparing two hash codes.

And it is dangerous to NOT identity two source datas are same using other approach when a collison occurs.

Image that the situation

As a parking space manager, Bob sends a message `You have a bill of parking space which its fee is 100 NT dollars.` to Alice.

If the message is NOT encrypted, 

a middle-man (a kind of hacker) can be more easier to intercept the message 

and then exchange message from `You have a bill of parking space which its fee is 100 NT dollars.` to `You own me 200 NT dollars.`

The alice might be confused.

To prevent this situation,

They can use **perfect hash function**.

First, he sends the message (a kind of plain text)(called M) and hash value (called H(M))to Alice.

Second, Alice recieves message from Bob (call M'), 

then she can use the same **perfect hash function** with input M`, getting a new hash value (called H(M'))

If H(M') is equal to H(M), it means that message has NOT been modified by others.

Otherwise, it means that message has been modified by others.

## Why comparing hash code first when comparing two instance?
1. For performance,

Because hash code is usually generated by a good hash function by default, 

in most cases, if two hash codes are different, means that two instance are considered to be different.

Additionally, in `C#`, comparing two hash codes (with `GetHashCode()` method call) takes even less time than comparing two instances.

as comparing two hash codes takes as long as comparing two number,

while, to compare two instances, it is needed to compare all value of property of two instance which takes very long.

That is one of reason why comparing hash code first when comparing two instance, 

it can improve performance.

2. For data integerity,

As discussed in above example (Bob sends a message to Alice)

## Why the compiler comparing hash code first when comparing two instance?
1. For performance,

The reason why is discussed above. We skip this part.

But, about how it benefits to developer in programming language, I will take some examples that are related to programming.

+ Take `Dictionary<TKey,TValue>` class in `C#` as example,

By default, it compares two hash codes first when checking there is an existing key given a table, it can narrow quickly narrow down the potential candidates for an existing key. 

The operations need to take O(1) (constant time).

But, if it didn't compare two hash codes, it needs to find all keys. 

The operations need to take O(n) (linear time)

### reference
+ [Google Gemini's` response -- Why the compiler comparing hash code first when comparing two instance?`](https://g.co/gemini/share/27168239ebd8)
+ [Google Gemini's response -- Time complexity of comparing hash code and comparing these value](https://g.co/gemini/share/75833add086c)

## Why the `GetHashCode` MUST be implemented?
Of course, it is declared in `IEqualityComparer<T>` interface.

If it is NOT be implemented in a class that implements `IEqualityComparer<T>` interface, then it will cause compile-time error.

Have you thought that it is declared in `IEqualityComparer<T>` interface?

I believe most of people never think about this question.

Before I took Kotlin course in Android App development course project at TibaMe, I didn't think this question.

After that, I knew that comparing hash code can improve performance.

However, after I read the [Google Gemini's response -- What occur when it is not implemented?],

Google Gemini's says there are still one reason -- data integerity and runtime safety (data integerity is one of requirement to ensure it is safe at runtime)

I didn't think these two reason.

Let's dive into the topic.

I take the following notes from [Google Gemini's response -- Why it is needed to implement `GetHashCode` method](https://g.co/gemini/share/9546f9613c81)

Take `Dictionary<TKey,TValue>` again for example.

If `Equals` methods says two objects are equal, their `GetHashCode` results must be identical.

If `GetHashCode` method definition were missing at runtime,

then during executing some operations (such as finding the specified key has already exists).  

It will crash or behave unpredictably (e.g., `NullReferenceException` if they tried to call a non-existent method, or  operate without proper hashing) might occur.

### reference
+ [Google Gemini's response -- Why it is needed to implement `GetHashCode` method](https://g.co/gemini/share/9546f9613c81)


